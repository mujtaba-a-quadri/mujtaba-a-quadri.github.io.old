---
layout: essay
type: essay
title: But What is an Abstraction?
# All dates must be YYYY-MM-DD format!
date: 2021-01-21
labels:
  - Software Engineering
  - Abstraction
---

I've always found this idea in programming of breaking down problems into smaller problems to be able to comprehend them very fascinating. Well, I shouldn't say *always*, I only started programming in the last few years of my life. But it's a very intriguing concept: can't solve a problem? Break it into smaller (and smaller) pieces until you can! It applies generally to things outside of programming too, which is one of the big skills gained by learning to code. This process is apparently called decomposition, I say "apparently" because it was news to me that there even *was* a name. Judging by the title, you probably know where this is going next: to the opposite of decomposition, which is abstraction.

### Abstraction
Maybe it seems incorrect to label abstraction as the opposite of decomposition, after all the opposite of decomposition seems like it would be... composition. Composition in this context would then mean bringing together all the small pieces into the whole, like what you do after finishing a problem by solving all the pieces you decomposed. But that's the very *literal* opposite of decomposition, the more conceptual opposite would be abstraction, I think. I say this because abstraction and decomposition are not really literal things that you *do* (while composition *is* something you literally do), they are models to help us comprehend big things: models that happen to go in different directions. Where Decomposition branches a problem into smaller problems, abstraction brings together complex processes that are too unweildy to fully understand into a simpler model (setting aside smaller details). 

### What Does This Have to do With Software?
Well I'm glad I asked. Everything we do on a computer is on top of layers and layers of abstraction. You can peel back those layers- say by using a command line. That probably peels back one layer of abstraction, but definitely not even close to all of them. Most people won't even go that far, there's no need for them: if it works, it works. And that's not a bad mindset to have, the reason we built these layers of abstraction is so that we aren't all constantly getting a headache. Imagine if we didn't have modern programming languages, and we wrote everything in assembly. And even *that* is still relying on levels of abstraction. As I said at the start, I'm still only a few years into programming so I hope to get more experience so that I can more fully understand how everything fits together (and not just an abstraction of everything, like right now). 













Like down here!
